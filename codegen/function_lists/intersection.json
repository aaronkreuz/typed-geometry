[
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class...",
                "variable_name": "Objs",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "merge_hits",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "line,",
                    "default_value": ""
                },
                {
                    "type_name": "Objs const&...",
                    "parameter_name": "objs",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    ScalarT hits[2] = {};\n    hits[0] = tg::max<ScalarT>();\n    hits[1] = tg::min<ScalarT>();\n    auto numHits = 0;\n\n    const auto find_hits = [&](const auto& obj)\n    {\n        const auto inters = intersection_parameter(line, obj);\n        for (const auto& inter : inters)\n        {\n            hits[0] = tg::min(hits[0], inter);\n            hits[1] = tg::max(hits[1], inter);\n            numHits++;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ObjT",
                "default_value": ""
            },
            {
                "typename": "u64",
                "variable_name": "N",
                "default_value": ""
            },
            {
                "typename": "size_t...",
                "variable_name": "I",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "merge_hits_array",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "line,",
                    "default_value": ""
                },
                {
                    "type_name": "array<ObjT, N>",
                    "parameter_name": "objs,",
                    "default_value": ""
                },
                {
                    "type_name": "std::index_sequence<I...>",
                    "parameter_name": "",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    return merge_hits(line, objs[I]...);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            },
            {
                "typename": "class...",
                "variable_name": "Objs",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_any",
            "parameters": [
                {
                    "type_name": "Obj const&",
                    "parameter_name": "obj,",
                    "default_value": ""
                },
                {
                    "type_name": "Objs const&...",
                    "parameter_name": "objs",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return (intersects(obj, objs) || ...);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ObjT",
                "default_value": ""
            },
            {
                "typename": "u64",
                "variable_name": "N",
                "default_value": ""
            },
            {
                "typename": "size_t...",
                "variable_name": "I",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_any_array",
            "parameters": [
                {
                    "type_name": "Obj const& obj, array<ObjT, N>",
                    "parameter_name": "objs,",
                    "default_value": ""
                },
                {
                    "type_name": "std::index_sequence<I...>",
                    "parameter_name": "",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects_any(obj, objs[I]...);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "solve_quadratic",
            "parameters": [
                {
                    "type_name": "ScalarT const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "ScalarT const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "ScalarT const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    const auto discriminant = b * b - ScalarT(4) * a * c;\n    if (discriminant < ScalarT(0))\n        return {}; // No solution\n\n    const auto sqrtD = sqrt(discriminant);\n    const auto t1 = (-b - sqrtD) / (ScalarT(2) * a);\n    const auto t2 = (-b + sqrtD) / (ScalarT(2) * a);\n\n    const auto [tMin, tMax] = minmax(t1, t2);\n    return {tMin, tMax};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment_object_impl",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "o",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    bool con_pos0 = contains(o, s.pos0);\n    bool con_pos1 = contains(o, s.pos1);\n\n    // case 1: Both seg. points are inside the convex object\n    if (con_pos0 && con_pos1)\n        return segment<3, ScalarT>{s.pos0, s.pos1};\n\n    line<3, ScalarT> segment_line = line<3, ScalarT>(s.pos0, normalize(s.pos1 - s.pos0));\n    auto insec = intersection_parameter(segment_line, o);\n\n    // no intersection exists\n    if (!insec.has_value())\n        return {};\n\n    // case 2: One seg. point inside the cylinder and one outside -> intersection with boundary must exist\n    if (con_pos0 || con_pos1)\n    {\n        // one point of the segment is inside the cylinder and one is outside -> intersection must exist\n        auto param = con_pos0 ? max(insec.value().start, insec.value().end) : min(insec.value().start, insec.value().end);\n        return segment<3, ScalarT>{segment_line.pos + segment_line.dir * param, con_pos0 ? s.pos0 : s.pos1};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "std::enable_if_t<!can_apply<detail::try_closest_intersection_parameter, A, B>, decltype(intersection(a, b).has_value())>"
        },
        "body": "    return intersection(a, b).has_value();\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "decltype(closest_intersection_parameter(a, b).has_value())"
        },
        "body": "    return closest_intersection_parameter(a, b).has_value();\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "enable_if<std::is_same_v<typename object_traits<A>::tag_t, boundary_tag>, bool>"
        },
        "body": "    using ScalarT = typename A::scalar_t;\n    auto const solidA = solid_of(a);\n    if (contains(solidA, b, ScalarT(-16) * tg::epsilon<ScalarT>))\n        return false;\n\n    return intersects(solidA, b);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "Obj const&",
                    "parameter_name": "obj",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(obj, b);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersectionTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "decltype(a[intersection_parameter(a, b)])"
        },
        "body": "    return a[intersection_parameter(a, b)];\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersectionTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<decltype(a[intersection_parameter(a, b).value()])>"
        },
        "body": "    if (auto t = intersection_parameter(a, b); t.has_value())\n        return a[t.value()];\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "closest_intersection",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "decltype(a[closest_intersection_parameter(a, b)])"
        },
        "body": "    return a[closest_intersection_parameter(a, b)];\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "closest_intersection",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<decltype(a[closest_intersection_parameter(a, b).value()])>"
        },
        "body": "    if (auto t = closest_intersection_parameter(a, b); t.has_value())\n        return a[t.value()];\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersectionTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "typename decltype(intersection_parameter(a, b))::template as_hits<typename A::pos_t>"
        },
        "body": "    auto ts = intersection_parameter(a, b);\n    typename A::pos_t hits[ts.max_hits] = {};\n    for (auto i = 0; i < ts.size(); ++i)\n        hits[i] = a[ts[i]];\n    return {hits, ts.size()};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            },
            {
                "typename": "std::enable_if_t<decltype(intersection_parameter(std::declval<A>()",
                "variable_name": "std::declval<B>()).value())::is_hit_interval int>",
                "default_value": ""
            },
            {
                "typename": "=",
                "variable_name": "0",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersectionTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<object_traits<A>::domain_dimension, typename object_traits<A>::scalar_t>>"
        },
        "body": "    using seg_t = segment<object_traits<A>::domain_dimension, typename object_traits<A>::scalar_t>;\n    auto ts = intersection_parameter(a, b);\n    if (ts.has_value())\n        return seg_t{a[ts.value().start], a[ts.value().end]};\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "closest_intersection_parameter",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<typename decltype(intersection_parameter(a, b))::hit_t>"
        },
        "body": "    const auto hits = intersection_parameter(a, b);\n    if (hits.any())\n        return hits.first();\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "closest_intersection_parameter",
            "parameters": [
                {
                    "type_name": "A const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "B const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<decltype(intersection_parameter(a, b).value().start)>"
        },
        "body": "    const auto hits = intersection_parameter(a, b);\n    if (hits.has_value())\n        return hits.value().start;\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameterTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "Obj const&",
                    "parameter_name": "obj",
                    "default_value": ""
                }
            ],
            "return_type": "enable_if<!std::is_same_v<Obj, decltype(boundary_of(obj))>, cc::optional<hit_interval<ScalarT>>>"
        },
        "body": "    const hits<2, ScalarT> inter = intersection_parameter(l, boundary_of(obj));\n\n    if (inter.size() == 2)\n        return {{inter[0], inter[1]}};\n\n    if constexpr (object_traits<Obj>::is_finite)\n    {\n        TG_ASSERT(inter.size() == 0); // a line intersects a finite solid object either twice or not at all\n        return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameterTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "ray<D, ScalarT> const&",
                    "parameter_name": "ray,",
                    "default_value": ""
                },
                {
                    "type_name": "Obj const&",
                    "parameter_name": "obj",
                    "default_value": ""
                }
            ],
            "return_type": "decltype(intersection_parameter(inf_of(ray), obj).is_hits, intersection_parameter(inf_of(ray), obj))"
        },
        "body": "    const auto inter = intersection_parameter(inf_of(ray), obj);\n    constexpr auto maxHits = inter.max_hits;\n    if (!inter.any() || inter.last() < ScalarT(0))\n        return {};\n\n    if constexpr (maxHits == 2)\n    {\n        if (inter.first() < ScalarT(0))\n            return {inter[1]};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameterTODO_MANUALLY",
            "parameters": [
                {
                    "type_name": "ray<D, ScalarT> const&",
                    "parameter_name": "ray,",
                    "default_value": ""
                },
                {
                    "type_name": "Obj const&",
                    "parameter_name": "obj",
                    "default_value": ""
                }
            ],
            "return_type": "decltype(intersection_parameter(inf_of(ray), obj).value().is_hit_interval, intersection_parameter(inf_of(ray), obj))"
        },
        "body": "    const auto inter = intersection_parameter(inf_of(ray), obj);\n\n    if (!inter.has_value())\n        return inter;\n\n    auto interval = inter.value();\n    if (interval.end < ScalarT(0))\n        return {};\n\n    TG_ASSERT((interval.start <= ScalarT(0)) == contains(obj, ray.origin));\n\n    interval.start = max(interval.start, ScalarT(0));\n    return interval;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line1",
            "parameters": [
                {
                    "type_name": "line<1, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "pos<1, ScalarT> const&",
                    "parameter_name": "p",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    return coordinates(l, p);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l0,",
                    "default_value": ""
                },
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l1",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    // l0.pos + l0.dir * t.x == l1.pos + l1.dir * t.y  <=>  (l0.dir | -l1.dir) * (t.x | t.y)^T == l1.pos - l0.pos\n    auto M = mat<2, 2, ScalarT>::from_cols(l0.dir, -l1.dir);\n    auto t = inverse(M) * (l1.pos - l0.pos);\n    if (!tg::is_finite(t.x))\n        return {};\n    return t.x;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "ray<2, ScalarT> const&",
                    "parameter_name": "r",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    auto M = mat<2, 2, ScalarT>::from_cols(l.dir, -r.dir);\n    auto t = inverse(M) * (r.origin - l.pos);\n    if (t.y < ScalarT(0) || !tg::is_finite(t.x))\n        return {};\n    return t.x;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<2, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    auto M = mat<2, 2, ScalarT>::from_cols(l.dir, s.pos0 - s.pos1);\n    auto t = inverse(M) * (s.pos0 - l.pos);\n    if (t.y < ScalarT(0) || t.y > ScalarT(1) || !tg::is_finite(t.x))\n        return {};\n    return t.x;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<D, ScalarT> const&",
                    "parameter_name": "p",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    const auto dotND = dot(p.normal, l.dir);\n    if (dotND == ScalarT(0)) // if plane normal and line direction are orthogonal, there is no intersection\n        return {};\n\n    // <l.pos + t * l.dir, p.normal> = p.dis  <=>  t = (p.dis - <l.pos, p.normal>) / <l.dir, p.normal>\n    return (p.dis - dot(p.normal, l.pos)) / dotND;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<D, ScalarT> const&",
                    "parameter_name": "h",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<hit_interval<ScalarT>>"
        },
        "body": "    const auto dotND = dot(h.normal, l.dir);\n    const auto dist = signed_distance(l.pos, h);\n\n    if (dotND == ScalarT(0)) // if halfspace normal and line direction are orthogonal, there is no intersection\n    {\n        if (dist <= ScalarT(0))\n            return {{tg::min<ScalarT>(), tg::max<ScalarT>()}}; // completely contained\n        return {};                                             // completely outside\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "closest_intersection_parameter",
            "parameters": [
                {
                    "type_name": "ray<D, ScalarT> const&",
                    "parameter_name": "r,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<D, ScalarT> const&",
                    "parameter_name": "h",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<ScalarT>"
        },
        "body": "    // check if ray origin is already contained in the halfspace\n    const auto dist = signed_distance(r.origin, h);\n    if (dist <= ScalarT(0))\n        return ScalarT(0);\n\n    // if ray points away from the halfspace there is no intersection\n    const auto dotND = dot(h.normal, r.dir);\n    if (dotND >= ScalarT(0))\n        return {};\n\n    return -dist / dotND;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb_boundary<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    // based on ideas from https://gamedev.stackexchange.com/q/18436\n    auto tFirst = tg::min<ScalarT>();\n    auto tSecond = tg::max<ScalarT>();\n    for (auto i = 0; i < D; ++i)\n    {\n        if (abs(l.dir[i]) > ScalarT(100) * tg::epsilon<ScalarT>)\n        {\n            const auto tMin = (b.min[i] - l.pos[i]) / l.dir[i];\n            const auto tMax = (b.max[i] - l.pos[i]) / l.dir[i];\n            tFirst = max(tFirst, min(tMin, tMax));\n            tSecond = min(tSecond, max(tMin, tMax));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "box_boundary<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    const auto bMin = b[comp<D, ScalarT>(-1)] - l.pos;\n    const auto bMax = b[comp<D, ScalarT>(1)] - l.pos;\n    auto tFirst = tg::min<ScalarT>();\n    auto tSecond = tg::max<ScalarT>();\n    for (auto i = 0; i < D; ++i)\n    {\n        const auto rDir = dot(l.dir, b.half_extents[i]);\n        if (abs(rDir) > ScalarT(100) * tg::epsilon<ScalarT>)\n        {\n            const auto tMin = dot(bMin, b.half_extents[i]) / rDir;\n            const auto tMax = dot(bMax, b.half_extents[i]) / rDir;\n            tFirst = max(tFirst, min(tMin, tMax));\n            tSecond = min(tSecond, max(tMin, tMax));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "box<2, ScalarT, 3> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    const auto t = intersection_parameter(l, plane<3, ScalarT>(normal_of(b), b.center));\n    if (!t.any()) // line parallel to box plane\n        return {};\n\n    const auto p = l[t.first()] - b.center;\n    if (abs(dot(b.half_extents[0], p)) > length_sqr(b.half_extents[0]) || abs(dot(b.half_extents[1], p)) > length_sqr(b.half_extents[1]))\n        return {};\n\n    return t;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "d",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    const auto t = intersection_parameter(l, plane<3, ScalarT>(d.normal, d.center));\n    if (!t.any()) // line parallel to disk plane\n        return {};\n\n    const auto p = l[t.first()];\n    if (distance_sqr(p, d.center) > d.radius * d.radius)\n        return {};\n\n    return t;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<D, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    auto t = dot(s.center - l.pos, l.dir);\n\n    auto d_sqr = distance_sqr(l[t], s.center);\n    auto r_sqr = s.radius * s.radius;\n    if (d_sqr > r_sqr)\n        return {};\n\n    auto dt = sqrt(r_sqr - d_sqr);\n    return {t - dt, t + dt};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "hemisphere_boundary<D, ScalarT> const&",
                    "parameter_name": "h",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    return detail::merge_hits(l, caps_of(h), boundary_no_caps_of(h));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "hemisphere_boundary_no_caps<D, ScalarT> const&",
                    "parameter_name": "h",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    ScalarT hits[2] = {};\n    auto numHits = 0;\n    const auto sphereHits = intersection_parameter(l, sphere_boundary<D, ScalarT>(h.center, h.radius));\n    const auto halfSpace = halfspace<D, ScalarT>(-h.normal, h.center); // the intersection of this halfspace and the sphere is exactly the hemisphere\n    for (const auto& hit : sphereHits)\n        if (contains(halfSpace, l[hit]))\n            hits[numHits++] = hit;\n\n    return {hits, numHits};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            },
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "TraitsT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "Obj const& lr, hemisphere<D, ScalarT, TraitsT> const&",
                    "parameter_name": "h",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    static_assert(object_traits<Obj>::is_infinite, \"For finite objects, complete containment within boundary has to be considered as well\");\n    if constexpr (std::is_same_v<TraitsT, boundary_no_caps_tag>)\n        return intersection_parameter(lr, h).any();\n    else\n        return detail::intersects_any(lr, caps_of(h), boundary_no_caps_of(h));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "capsule_boundary<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    using caps_t = hemisphere_boundary_no_caps<3, ScalarT>;\n    const auto n = direction(c);\n    return detail::merge_hits(l, caps_t(c.axis.pos0, c.radius, -n), caps_t(c.axis.pos1, c.radius, n), cylinder_boundary_no_caps<3, ScalarT>(c.axis, c.radius));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "TraitsT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "Obj const& lr, capsule<3, ScalarT, TraitsT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    static_assert(object_traits<Obj>::is_infinite, \"For finite objects, complete containment within boundary has to be considered as well\");\n    using caps_t = sphere_boundary<3, ScalarT>; // spheres are faster than hemispheres and equivalent for the yes/no decision\n    return detail::intersects_any(lr, caps_t(c.axis.pos0, c.radius), caps_t(c.axis.pos1, c.radius), cylinder_boundary_no_caps<3, ScalarT>(c.axis, c.radius));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "cylinder_boundary<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    const auto caps = caps_of(c);\n    return detail::merge_hits(l, caps[0], caps[1], boundary_no_caps_of(c));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "Obj",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "TraitsT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "Obj const& lr, cylinder<3, ScalarT, TraitsT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    static_assert(object_traits<Obj>::is_infinite, \"For finite objects, complete containment within boundary has to be considered as well\");\n    if constexpr (std::is_same_v<TraitsT, boundary_no_caps_tag>)\n        return intersection_parameter(lr, c).any();\n    else\n    {\n        const auto caps = caps_of(c);\n        return detail::intersects_any(lr, caps[0], caps[1], boundary_no_caps_of(c));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "cylinder_boundary_no_caps<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    auto const infInter = intersection_parameter(l, inf_of(c));\n    if (!infInter.any())\n        return infInter;\n\n    auto const d = c.axis.pos1 - c.axis.pos0;\n    auto const lambda0 = dot(l[infInter[0]] - c.axis.pos0, d);\n    auto const lambda1 = dot(l[infInter[1]] - c.axis.pos0, d);\n\n    ScalarT hits[2] = {};\n    auto numHits = 0;\n    auto const dDotD = dot(d, d);\n    if (ScalarT(0) <= lambda0 && lambda0 <= dDotD)\n        hits[numHits++] = infInter[0];\n    if (ScalarT(0) <= lambda1 && lambda1 <= dDotD)\n        hits[numHits++] = infInter[1];\n\n    return {hits, numHits};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "inf_cylinder_boundary<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    auto const cosA = dot(c.axis.dir, l.dir);\n    auto const sinA_sqr = 1 - cosA * cosA;\n\n    if (sinA_sqr <= 0)\n        return {}; // line and cylinder are parallel\n\n    // compute closest points of line and cylinder axis\n    auto const origDiff = l.pos - c.axis.pos;\n    auto const fLine = dot(l.dir, origDiff);\n    auto const fAxis = dot(c.axis.dir, origDiff);\n    auto const tLine = (cosA * fAxis - fLine) / sinA_sqr;\n    auto const tAxis = (fAxis - cosA * fLine) / sinA_sqr;\n\n    auto const line_axis_dist_sqr = distance_sqr(l[tLine], c.axis[tAxis]);\n    auto const cyl_radius_sqr = c.radius * c.radius;\n\n    if (cyl_radius_sqr < line_axis_dist_sqr)\n        return {}; // line misses the cylinder\n\n    // radius in 2D slice = sqrt(cyl_radius_sqr - line_axis_dist_sqr)\n    // infinite tube intersection\n    auto const s = sqrt((cyl_radius_sqr - line_axis_dist_sqr) / sinA_sqr);\n    return {tLine - s, tLine + s};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "inf_cylinder_boundary<2, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    const auto n = perpendicular(c.axis.dir);\n    const auto d = dot(l.dir, n);\n    if (d == ScalarT(0)) // line parallel to inf_cylinder\n        return {};\n\n    const auto dist = dot(c.axis.pos - l.pos, n);\n    const auto [tMin, tMax] = minmax((dist - c.radius) / d, (dist + c.radius) / d);\n    return {tMin, tMax};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "inf_cone_boundary<2, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    auto ray1 = ray<2, ScalarT>(c.apex, rotate(c.opening_dir, c.opening_angle / ScalarT(2)));\n    auto ray2 = ray<2, ScalarT>(c.apex, rotate(c.opening_dir, -c.opening_angle / ScalarT(2)));\n    return detail::merge_hits(l, ray1, ray2);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "inf_cone_boundary<3, ScalarT> const&",
                    "parameter_name": "ic",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    // see https://lousodrome.net/blog/light/2017/01/03/intersection-of-a-ray-and-a-cone/\n    auto const dv = dot(l.dir, ic.opening_dir);\n    auto const cos2 = pow2(cos(ic.opening_angle * ScalarT(0.5)));\n    auto const co = l.pos - ic.apex;\n    auto const cov = dot(co, ic.opening_dir);\n    auto const a = dv * dv - cos2;\n    auto const b = ScalarT(2) * (dv * cov - dot(l.dir, co) * cos2);\n    auto const c = cov * cov - dot(co, co) * cos2;\n    auto const inter = detail::solve_quadratic(a, b, c);\n    if (!inter.any())\n        return inter;\n\n    // exclude intersections with mirrored cone\n    ScalarT hits[2] = {};\n    auto numHits = 0;\n    TG_ASSERT(ic.opening_angle <= tg::angle::from_degree(ScalarT(180))\n              && \"Only convex objects are supported, but an inf_cone with openinge angle > 180 degree is not convex.\");\n    // if it is not used for solid cones, this works:\n    // auto const coneDir = ic.opening_angle > 180_deg ? -ic.opening_dir : ic.opening_dir;\n    // if (dot(l[inter[0]] - ic.apex, coneDir) >= ScalarT(0)) ...\n    if (dot(l[inter[0]] - ic.apex, ic.opening_dir) >= ScalarT(0))\n        hits[numHits++] = inter[0];\n    if (dot(l[inter[1]] - ic.apex, ic.opening_dir) >= ScalarT(0))\n        hits[numHits++] = inter[1];\n\n    return {hits, numHits};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "cone_boundary_no_caps<3, ScalarT> const&",
                    "parameter_name": "cone",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    auto const apex = apex_of(cone);\n    auto const openingDir = -normal_of(cone.base);\n    auto const borderPos = any_point(boundary_of(cone.base));\n    auto const openingAngleHalf = angle_between(openingDir, normalize(borderPos - apex));\n\n    // see https://lousodrome.net/blog/light/2017/01/03/intersection-of-a-ray-and-a-cone/\n    auto const dv = dot(l.dir, openingDir);\n    auto const cos2 = pow2(cos(openingAngleHalf));\n    auto const co = l.pos - apex;\n    auto const cov = dot(co, openingDir);\n    auto const a = dv * dv - cos2;\n    auto const b = ScalarT(2) * (dv * cov - dot(l.dir, co) * cos2);\n    auto const c = cov * cov - dot(co, co) * cos2;\n    auto const inter = detail::solve_quadratic(a, b, c);\n    if (!inter.any())\n        return inter;\n\n    // exclude intersections with mirrored cone\n    ScalarT hits[2] = {};\n    auto numHits = 0;\n    auto const h0 = dot(l[inter[0]] - apex, openingDir);\n    auto const h1 = dot(l[inter[1]] - apex, openingDir);\n    if (ScalarT(0) <= h0 && h0 <= cone.height)\n        hits[numHits++] = inter[0];\n    if (ScalarT(0) <= h1 && h1 <= cone.height)\n        hits[numHits++] = inter[1];\n\n    return {hits, numHits};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "BaseT",
                "default_value": ""
            },
            {
                "typename": "typename",
                "variable_name": "",
                "default_value": "std::enable_if_t<!std::is_same_v<BaseT sphere<2 typename BaseT::scalar_t 3>>>"
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, typename BaseT::scalar_t> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "pyramid_boundary_no_caps<BaseT> const&",
                    "parameter_name": "py",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,typenameBaseT::scalar_t>"
        },
        "body": "    auto const faces = faces_of(py);\n    return detail::merge_hits_array(l, faces, std::make_index_sequence<faces.size()>{});\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "BaseT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, typename BaseT::scalar_t> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "pyramid_boundary<BaseT> const&",
                    "parameter_name": "py",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,typenameBaseT::scalar_t>"
        },
        "body": "    return detail::merge_hits(l, py.base, boundary_no_caps_of(py));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<2, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<hit_interval<ScalarT>>"
        },
        "body": "    ScalarT closestIntersection = tg::max<ScalarT>();\n    ScalarT furtherIntersection = tg::min<ScalarT>();\n    auto numIntersections = 0;\n    for (const auto& edge : edges_of(t))\n    {\n        const auto inter = intersection_parameter(l, edge);\n        if (inter.any())\n        {\n            numIntersections++;\n            closestIntersection = min(closestIntersection, inter.first());\n            furtherIntersection = max(furtherIntersection, inter.first());\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "dont_deduce<ScalarT>",
                    "parameter_name": "eps",
                    "default_value": "100 * tg::epsilon<ScalarT>"
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    auto e1 = t.pos1 - t.pos0;\n    auto e2 = t.pos2 - t.pos0;\n\n    auto pvec = tg::cross(l.dir, e2);\n    auto det = dot(pvec, e1);\n\n    if (det < ScalarT(0))\n    {\n        std::swap(e1, e2);\n        pvec = tg::cross(l.dir, e2);\n        det = -det;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "ellipse<2, ScalarT, 3> const&",
                    "parameter_name": "e",
                    "default_value": ""
                }
            ],
            "return_type": "hits<1,ScalarT>"
        },
        "body": "    const auto t = intersection_parameter(l, plane<3, ScalarT>(normal_of(e), e.center));\n    if (!t.any()) // line parallel to ellipse plane\n        return {};\n\n    // simplified contains(e, p) without plane check and eps == 0\n    auto pc = l[t.first()] - e.center;\n    auto x = dot(pc, e.semi_axes[0]);\n    auto y = dot(pc, e.semi_axes[1]);\n    auto a = length_sqr(e.semi_axes[0]);\n    auto b = length_sqr(e.semi_axes[1]);\n\n    if (pow2(x / a) + pow2(y / b) <= ScalarT(1))\n        return t;\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line",
            "parameters": [
                {
                    "type_name": "line<D, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "ellipse_boundary<D, ScalarT> const&",
                    "parameter_name": "e",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    // transform line to ellipse space (ellipse gets unit sphere at origin)\n    auto const pc = l.pos - e.center;\n    vec<D, ScalarT> p;\n    vec<D, ScalarT> d; // in ellipse space, this is no longer a unit vector\n    for (auto i = 0; i < D; ++i)\n    {\n        auto const axis2 = dot(e.semi_axes[i], e.semi_axes[i]);\n        p[i] = dot(pc, e.semi_axes[i]) / axis2;\n        d[i] = dot(l.dir, e.semi_axes[i]) / axis2;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_line3",
            "parameters": [
                {
                    "type_name": "line<3, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "quadric<3, ScalarT> const&",
                    "parameter_name": "q",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,ScalarT>"
        },
        "body": "    const auto Ad = q.A() * l.dir;\n    const auto p = l.pos;\n\n    // Substituting x in Quadric equation x^TAx + 2b^Tx + c = 0 by ray equation x = t * dir + p yields\n    // d^TAd t^2 + (2p^TAd + 2bd) t + p^TAp + 2bp + c = 0\n    const auto a = dot(l.dir, Ad);\n    const auto b = ScalarT(2) * (dot(p, Ad) + dot(q.b(), l.dir));\n    const auto c = dot(p, q.A() * vec3(p)) + ScalarT(2) * dot(q.b(), p) + q.c;\n    return detail::solve_quadratic(a, b, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere_boundary3",
            "parameters": [
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<sphere_boundary<2,ScalarT,3>>"
        },
        "body": "    auto d2 = distance_sqr(a.center, b.center);\n\n    // TODO: intersection sphere\n    if (a.center == b.center && a.radius == b.radius)\n        return {};\n\n    auto d = sqrt(d2);\n\n    // no intersection\n    if (d > a.radius + b.radius)\n        return {};\n\n    // radius and centers of larger sphere (ls) and smaller sphere (ss)\n    auto lsr = a.radius;\n    auto ssr = b.radius;\n    auto lsc = a.center;\n    auto ssc = b.center;\n    if (b.radius > a.radius)\n    {\n        // TODO: tg::swap?\n        lsr = b.radius;\n        ssr = a.radius;\n        lsc = b.center;\n        ssc = a.center;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere_boundary2",
            "parameters": [
                {
                    "type_name": "sphere_boundary<2, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<pair<pos<2,ScalarT>,pos<2,ScalarT>>>"
        },
        "body": "    if (a.center == b.center && a.radius == b.radius)\n        return {}; // degenerate case\n\n    auto d2 = distance_sqr(a.center, b.center);\n    auto d = sqrt(d2);\n    auto ar = a.radius;\n    auto br = b.radius;\n    if (ar + br < d) // no intersection\n        return {};\n\n    if (d < abs(ar - br)) // no intersection (one inside the other)\n        return {};\n\n    TG_INTERNAL_ASSERT(d > ScalarT(0));\n\n    auto t = (ar * ar - br * br + d2) / (2 * d);\n    auto h2 = ar * ar - t * t;\n    TG_INTERNAL_ASSERT(h2 >= ScalarT(0));\n\n    auto h = sqrt(h2);\n    auto h_by_d = h / d;\n\n    auto p_between = a.center + t / d * (b.center - a.center);\n\n    auto a_to_b = b.center - a.center;\n    auto a_to_b_swap = tg::vec2(-a_to_b.y, a_to_b.x);\n\n    // imagining circle a on the left side of circle b...\n    auto p_above = p_between + h_by_d * a_to_b_swap;\n    auto p_below = p_between - h_by_d * a_to_b_swap;\n\n    return pair{p_above, p_below};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere_boundary3",
            "parameters": [
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<sphere_boundary<2,ScalarT,3>>"
        },
        "body": "    auto const d = dot(a.center, b.normal) - b.dis;\n    if (d > a.radius)\n        return {};\n    if (d < -a.radius)\n        return {};\n\n    sphere_boundary<2, ScalarT, 3> r;\n    r.center = a.center - b.normal * d;\n    r.normal = d >= ScalarT(0) ? b.normal : -b.normal;\n    r.radius = sqrt(a.radius * a.radius - d * d);\n    return r;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_plane3",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<sphere_boundary<2,ScalarT,3>>"
        },
        "body": "    auto r = intersection(b, a);\n    if (r.has_value())\n    {\n        auto c = r.value();\n        c.normal = -c.normal; // make sure to point from a to b\n        return c;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere2",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3, boundary_tag> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,pos<3,ScalarT>>"
        },
        "body": "    auto const l = intersection(plane_of(a), b);\n    return intersection(l, sphere_boundary<3, ScalarT>(a.center, a.radius));\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_plane3",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3, boundary_tag> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,pos<3,ScalarT>>"
        },
        "body": "    return intersection(b, a);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere2",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3, boundary_tag> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,pos<3,ScalarT>>"
        },
        "body": "    auto const is = intersection(plane_of(a), s);\n    if (!is.has_value())\n        return {};\n\n    auto const b = is.value();\n\n    auto d2 = distance_sqr(a.center, b.center);\n    auto d = sqrt(d2);\n    auto ar = a.radius;\n    auto br = b.radius;\n    if (ar + br < d) // no intersection\n        return {};\n\n    if (d < abs(ar - br)) // no intersection (one inside the other)\n        return {};\n\n    TG_INTERNAL_ASSERT(d > ScalarT(0));\n\n    auto t = (ar * ar - br * br + d2) / (2 * d);\n    auto h2 = ar * ar - t * t;\n    TG_INTERNAL_ASSERT(h2 >= ScalarT(0));\n\n    auto h = sqrt(h2);\n    auto h_by_d = h / d;\n\n    auto p_between = a.center + t / d * (b.center - a.center);\n\n    auto bitangent = cross(b.center - a.center, a.normal);\n\n    // imagining circle a on the left side of circle b...\n    auto p_above = p_between + h_by_d * bitangent;\n    auto p_below = p_between - h_by_d * bitangent;\n\n    return {p_above, p_below};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere_boundary3",
            "parameters": [
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3, boundary_tag> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,pos<3,ScalarT>>"
        },
        "body": "    return intersection(b, a);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_plane3",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "line<3,ScalarT>"
        },
        "body": "    // see http://mathworld.wolfram.com/Plane-PlaneIntersection.html\n    auto dir = normalize(cross(a.normal, b.normal));\n    auto p = pos<3, ScalarT>::zero;\n\n    if (abs(dir.z) > abs(dir.x)) // solve with p.z = 0\n    {\n        auto n0 = tg::vec<2, ScalarT>(a.normal.x, b.normal.x);\n        auto n1 = tg::vec<2, ScalarT>(a.normal.y, b.normal.y);\n        auto r = tg::vec<2, ScalarT>(a.dis, b.dis);\n        auto p2 = inverse(mat<2, 2, ScalarT>::from_cols(n0, n1)) * r;\n        p.x = p2.x;\n        p.y = p2.y;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameters_segment2",
            "parameters": [
                {
                    "type_name": "segment<2, ScalarT> const&",
                    "parameter_name": "seg_0,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<2, ScalarT> const&",
                    "parameter_name": "seg_1",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<pair<ScalarT,ScalarT>>"
        },
        "body": "    /// https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n    auto const denom = (seg_0.pos0.x - seg_0.pos1.x) * (seg_1.pos0.y - seg_1.pos1.y) - (seg_0.pos0.y - seg_0.pos1.y) * (seg_1.pos0.x - seg_1.pos1.x);\n\n    // todo: might want to check == 0 with an epsilon corridor\n    // todo: colinear line segments can still intersect in a point or a line segment.\n    //       This might require api changes, as either a point or a line segment can be returned!\n    //       Possible solution: return a segment where pos0 == pos1\n    if (denom == ScalarT(0))\n        return {}; // colinear\n\n    auto const num0 = (seg_0.pos0.x - seg_1.pos0.x) * (seg_1.pos0.y - seg_1.pos1.y) - (seg_0.pos0.y - seg_1.pos0.y) * (seg_1.pos0.x - seg_1.pos1.x);\n    auto const num1 = (seg_0.pos0.x - seg_0.pos1.x) * (seg_0.pos0.y - seg_1.pos0.y) - (seg_0.pos0.y - seg_0.pos1.y) * (seg_0.pos0.x - seg_1.pos0.x);\n    auto const t = num0 / denom;\n    auto const u = -num1 / denom;\n    if (ScalarT(0) <= t && t <= ScalarT(1) && ScalarT(0) <= u && u <= ScalarT(1))\n        return pair<ScalarT, ScalarT>{t, u};\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_segment2",
            "parameters": [
                {
                    "type_name": "segment<2, ScalarT> const&",
                    "parameter_name": "seg_0,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<2, ScalarT> const&",
                    "parameter_name": "seg_1",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<ScalarT>"
        },
        "body": "    auto ip = intersection_parameters(seg_0, seg_1);\n    if (ip.has_value())\n        return ip.value().first;\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameters_line2",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l0,",
                    "default_value": ""
                },
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l1",
                    "default_value": ""
                }
            ],
            "return_type": "pair<ScalarT,ScalarT>"
        },
        "body": "    auto M = mat<2, 2, ScalarT>::from_cols(l0.dir, -l1.dir);\n    auto t = inverse(M) * (l1.pos - l0.pos);\n    return {t.x, t.y};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_aabb",
            "parameters": [
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<aabb<D,ScalarT>>"
        },
        "body": "    for (auto i = 0; i < D; ++i)\n    {\n        if (a.max[i] < b.min[i])\n            return {};\n\n        if (b.max[i] < a.min[i])\n            return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_plane3",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "pos<3,ScalarT>"
        },
        "body": "    return intersection(intersection(a, b), c).first();\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_parameter_segment",
            "parameters": [
                {
                    "type_name": "segment<D, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<D, ScalarT> const&",
                    "parameter_name": "p",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<ScalarT>"
        },
        "body": "    auto denom = dot(p.normal, a.pos1 - a.pos0);\n    if (denom == ScalarT(0))\n        return {};\n\n    auto t = (p.dis - dot(p.normal, a.pos0)) / denom;\n    if (t < 0 || t > 1)\n        return {};\n    return t;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment",
            "parameters": [
                {
                    "type_name": "segment<D, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<D,ScalarT>>"
        },
        "body": "    // early-out: both segment points inside the sphere\n    if ((distance_sqr(a.pos0, b.center) < pow2(b.radius)) && (distance_sqr(a.pos1, b.center) < pow2(b.radius)))\n        return segment<D, ScalarT>{a.pos0, a.pos1};\n\n    auto const l = line<D, ScalarT>(a.pos0, normalize(a.pos1 - a.pos0));\n    auto const params = intersection_parameter(l, b);\n\n    if (!params.has_value())\n        return {};\n\n    if (params.value().is_unbounded())\n        return {};\n\n    auto const dist = distance(a.pos0, a.pos1);\n    auto n_hits = 0;\n    tg::pos<D, ScalarT> ps[2];\n\n    if (params.value().start < dist && params.value().start > ScalarT(0))\n        ps[n_hits++] = l[params.value().start];\n\n    if (params.value().end < dist && params.value().end > ScalarT(0))\n        ps[n_hits++] = l[params.value().end];\n\n    if (n_hits == 1)\n        return segment<D, ScalarT>{ps[0], ps[0]};\n\n    if (n_hits == 2)\n        return segment<D, ScalarT>{ps[0], ps[1]};\n\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere",
            "parameters": [
                {
                    "type_name": "sphere<D, ScalarT> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<D, ScalarT> const&",
                    "parameter_name": "a",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<D,ScalarT>>"
        },
        "body": "    return intersection(b, a);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere_boundary3",
            "parameters": [
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "sphere_boundary,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "segment",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,tg::pos<3,ScalarT>>"
        },
        "body": "    auto const line = line3::from_points(segment.pos0, segment.pos1);\n    auto const params = intersection_parameter(line, sphere_boundary);\n\n    if (!params.any())\n        return {};\n\n    auto const dist = distance(segment.pos0, segment.pos1);\n    auto n_hits = 0;\n    tg::pos<3, ScalarT> ps[2];\n    for (auto i = 0; i < params.size(); ++i)\n    {\n        auto const t = params[i];\n        if (ScalarT(0) <= t && t <= dist)\n        {\n            ps[n_hits++] = line[t];\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "segment,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere_boundary<3, ScalarT> const&",
                    "parameter_name": "sphere_boundary",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,tg::pos<3,ScalarT>>"
        },
        "body": "    return intersection(sphere_boundary, segment);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "are_separate",
            "parameters": [
                {
                    "type_name": "hit_interval<ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "hit_interval<ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return b.end < a.start || a.end < b.start;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "shadow",
            "parameters": [
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "vec<D, ScalarT> const&",
                    "parameter_name": "axis",
                    "default_value": ""
                }
            ],
            "return_type": "hit_interval<ScalarT>"
        },
        "body": "    auto const center = centroid_of(b);\n    auto const c = dot(center, axis);\n    auto const e = dot(b.max - center, abs(axis));\n    return {c - e, c + e};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "ObjectD",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "int",
                "variable_name": "DomainD",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "shadow",
            "parameters": [
                {
                    "type_name": "box<ObjectD, ScalarT, DomainD> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "vec<DomainD, ScalarT> const&",
                    "parameter_name": "axis",
                    "default_value": ""
                }
            ],
            "return_type": "hit_interval<ScalarT>"
        },
        "body": "    auto const c = dot(b.center, axis);\n    auto e = ScalarT(0);\n    for (auto i = 0; i < ObjectD; ++i)\n        e += abs(dot(b.half_extents[i], axis));\n\n    return {c - e, c + e};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "BaseT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "shadow",
            "parameters": [
                {
                    "type_name": "pyramid<BaseT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "vec<3, typename BaseT::scalar_t> const&",
                    "parameter_name": "axis",
                    "default_value": ""
                }
            ],
            "return_type": "hit_interval<typenameBaseT::scalar_t>"
        },
        "body": "    using ScalarT = typename BaseT::scalar_t;\n    auto tMin = tg::max<ScalarT>();\n    auto tMax = tg::min<ScalarT>();\n    for (auto const& vertex : vertices_of(p))\n    {\n        auto const t = dot(vertex, axis);\n        tMin = tg::min(tMin, t);\n        tMax = tg::max(tMax, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "A",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "B",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_SAT",
            "parameters": [
                {
                    "type_name": "A const& a, B const& b, span<vec<object_traits<B>::domain_dimension, typename B::scalar_t> const>",
                    "parameter_name": "axes",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    for (auto const& axis : axes)\n        if (are_separate(shadow(a, axis), shadow(b, axis)))\n            return false;\n\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "line<1, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<1, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    TG_UNUSED(l);\n    TG_UNUSED(b);\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "line<2, ScalarT> const&",
                    "parameter_name": "l,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const c = centroid_of(b);\n    auto const shadow = dot(b.max - c, abs(perpendicular(l.dir)));\n    return pow2(shadow) >= distance_sqr(c, l);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "ray<D, ScalarT> const&",
                    "parameter_name": "r,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    for (auto i = 0; i < D; ++i)\n    {\n        if ((r.origin[i] > b.max[i] && r.dir[i] >= ScalarT(0)) || (r.origin[i] < b.min[i] && r.dir[i] <= ScalarT(0)))\n            return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "segment<D, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (!intersects(aabb_of(s), b))\n        return false;\n\n    return intersects(inf_of(s), b);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<D, ScalarT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const c = centroid_of(b);\n    auto const shadow = dot(b.max - c, abs(p.normal));\n    return shadow >= distance(c, p); // Note: no square needed, since no sqrt involved\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<D, ScalarT> const&",
                    "parameter_name": "h,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const c = centroid_of(b);\n    auto const dist = signed_distance(c, h);\n    if (dist <= ScalarT(0))\n        return true;\n\n    auto const shadow = dot(b.max - c, abs(h.normal));\n    return shadow >= dist;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<D, ScalarT> const&",
                    "parameter_name": "h,",
                    "default_value": ""
                },
                {
                    "type_name": "box<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const c = centroid_of(b);\n    auto const dist = signed_distance(c, h);\n    if (dist <= ScalarT(0))\n        return true;\n\n    auto shadow = tg::abs(dot(b.half_extents[0], h.normal));\n    if constexpr (D >= 2)\n        shadow += tg::abs(dot(b.half_extents[1], h.normal));\n    if constexpr (D >= 3)\n        shadow += tg::abs(dot(b.half_extents[2], h.normal));\n    if constexpr (D >= 4)\n        shadow += tg::abs(dot(b.half_extents[3], h.normal));\n\n    return shadow >= dist;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    for (auto i = 0; i < D; ++i)\n    {\n        if (b.max[i] < a.min[i] || a.max[i] < b.min[i])\n            return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "aabb_boundary<D, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto contained = true;\n    for (auto i = 0; i < D; ++i)\n    {\n        if (b.max[i] < a.min[i] || a.max[i] < b.min[i])\n            return false;\n\n        contained = contained && a.min[i] < b.min[i] && b.max[i] < a.max[i];\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "ObjectD",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            },
            {
                "typename": "int",
                "variable_name": "DomainD",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<ObjectD, ScalarT, DomainD> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<DomainD, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (!intersects(aabb_of(box), b))\n        return false;\n\n    if constexpr (DomainD == 1)\n        return true; // the only axis was already checked above\n\n    using vec_t = vec<DomainD, ScalarT>;\n\n    constexpr int max_axes_count = DomainD + (DomainD > 2 ? DomainD * DomainD : 0);\n\n    auto axes = array<vec_t, max_axes_count>();\n    size_t curr_axis = 0;\n\n    [[maybe_unused]] auto axisDirs = tg::array<vec_t, DomainD>();\n    if constexpr (DomainD == 3)\n        axisDirs = {vec_t::unit_x, vec_t::unit_y, vec_t::unit_z};\n\n    for (auto i = 0; i < DomainD; ++i)\n    {\n        vec_t d;\n        if constexpr (ObjectD == 2 && DomainD == 3) // box2in3\n            d = i == 2 ? normal_of(box) : box.half_extents[i];\n        else\n            d = box.half_extents[i];\n        axes[curr_axis++] = d;\n\n        if constexpr (DomainD > 2)\n            for (auto j = 0u; j < DomainD; ++j)\n                axes[curr_axis++] = cross(d, axisDirs[j]);\n\n        static_assert(DomainD < 4 && \"Not implemented for 4D\");\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box_boundary<2, ScalarT, 3> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return detail::intersects_any_array(b, edges_of(box), std::make_index_sequence<4>{});\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<D, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const b_min = b.min;\n    auto const b_max = b.max;\n    auto const c = s.center;\n    auto const clamped_sqr = [](ScalarT v)\n    {\n        v = tg::max(ScalarT(0), v);\n        return v * v;\n    };\n\n    auto d_min = ScalarT(0);\n\n    if constexpr (D >= 1)\n    {\n        d_min += clamped_sqr(b_min.x - c.x);\n        d_min += clamped_sqr(c.x - b_max.x);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<1, ScalarT, 2> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const v = perpendicular(s.normal) * s.radius;\n    return intersects(segment<2, ScalarT>(s.center - v, s.center + v), b);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere_boundary<1, ScalarT, 2> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const v = perpendicular(s.normal) * s.radius;\n    return contains(b, s.center - v) || contains(b, s.center + v);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const diskPlane = plane<3, ScalarT>(s.normal, s.center);\n    if (!intersects(diskPlane, b))\n        return false;\n\n    // early out, contains SAT for each aabb axis\n    if (!intersects(sphere<3, ScalarT>(s.center, s.radius), b))\n        return false;\n\n    // check if disk extrema are within aabb. cross(cross(axisDir, n)) yields the following vectors\n    if (contains(b, s.center))\n        return true;\n    auto const c = s.center;\n    auto const n = s.normal;\n    using vec_t = vec<3, ScalarT>;\n    auto const vx = s.radius * normalize(vec_t(-n.y * n.y - n.z * n.z, n.x * n.y, n.x * n.z));\n    if (contains(b, c + vx) || contains(b, c - vx))\n        return true;\n    auto const vy = s.radius * normalize(vec_t(n.x * n.y, -n.x * n.x - n.z * n.z, n.y * n.z));\n    if (contains(b, c + vy) || contains(b, c - vy))\n        return true;\n    auto const vz = s.radius * normalize(vec_t(n.x * n.z, n.y * n.z, -n.x * n.x - n.y * n.y));\n    if (contains(b, c + vz) || contains(b, c - vz))\n        return true;\n\n    // intersection test with each aabb edge\n    for (auto const& edge : edges_of(b))\n        if (intersects(edge, s))\n            return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere_boundary<2, ScalarT, 3> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const diskPlane = plane<3, ScalarT>(s.normal, s.center);\n    if (!intersects(diskPlane, b))\n        return false;\n\n    // early out, contains SAT for each aabb axis\n    if (!intersects(sphere<3, ScalarT>(s.center, s.radius), b))\n        return false;\n\n    // check if disk extrema are within aabb. cross product of axis dir and two times with n yield the following vectors\n    auto const c = s.center;\n    auto const n = s.normal;\n    using vec_t = vec<3, ScalarT>;\n    auto const eps = ScalarT(16) * epsilon<ScalarT>;\n    auto const vx = s.radius * normalize(vec_t(-n.y * n.y - n.z * n.z, n.x * n.y, n.x * n.z));\n    if (contains(b, c + vx, eps) || contains(b, c - vx, eps))\n        return true;\n    auto const vy = s.radius * normalize(vec_t(n.x * n.y, -n.x * n.x - n.z * n.z, n.y * n.z));\n    if (contains(b, c + vy, eps) || contains(b, c - vy, eps))\n        return true;\n    auto const vz = s.radius * normalize(vec_t(n.x * n.z, n.y * n.z, -n.x * n.x - n.y * n.y));\n    if (contains(b, c + vz, eps) || contains(b, c - vz, eps))\n        return true;\n\n    // intersection test with each aabb edge\n    auto inside = 0, outside = 0;\n    for (auto const& edge : edges_of(b))\n    {\n        auto const t = intersection(edge, diskPlane);\n        if (!t.has_value())\n            continue;\n        if (distance_sqr(t.value(), s.center) <= pow2(s.radius))\n            inside++;\n        else\n            outside++;\n\n        if (inside > 0 && outside > 0)\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "hemisphere<D, ScalarT> const&",
                    "parameter_name": "h,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const closestP = project(h.center, b);\n    return contains(h, closestP) || intersects(caps_of(h), b);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "hemisphere_boundary_no_caps<1, ScalarT> const&",
                    "parameter_name": "h,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<1, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return contains(b, h.center + h.radius * h.normal);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "hemisphere_boundary_no_caps<D, ScalarT> const&",
                    "parameter_name": "h,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto const fullSphere = sphere<D, ScalarT>(h.center, h.radius);\n    if (!intersects(fullSphere, b))\n        return false; // early out\n\n    if (intersects(caps_of(h), b))\n        return true;\n\n    // classify aabb vertices\n    auto const spaceUnder = halfspace<D, ScalarT>(h.normal, h.center);\n    auto inside = 0, outside = 0, under = 0;\n    for (auto const& vertex : vertices_of(b))\n    {\n        if (contains(spaceUnder, vertex))\n            under++;\n        else if (contains(fullSphere, vertex))\n            inside++;\n        else\n            outside++;\n\n        if (inside > 0 && outside > 0)\n            return true; // has to intersect the boundary\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "capsule<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (!intersects(aabb_of(c), b))\n        return false;\n\n    // check if the line through the axis intersects the aabb\n    auto const line = inf_of(c.axis);\n    auto const hits = intersection_parameter(line, boundary_of(b));\n    if (hits.any())\n    {\n        auto const len = length(c.axis);\n        auto const t = clamp(hits.first(), ScalarT(0), len);\n        for (auto const& hit : hits)\n        {\n            if (ScalarT(0) - c.radius <= hit && hit <= len + c.radius)\n                return true; // capsule axis intersects aabb\n\n            if (t != clamp(hit, ScalarT(0), len))\n                return true; // intersections before and after the axis can only occur if it lies within aabb\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "cylinder<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (!intersects(aabb_of(c), b))\n        return false;\n\n    // check if the line through the axis intersects the aabb\n    auto const line = inf_of(c.axis);\n    auto const len = length(c.axis);\n    auto const hits = intersection_parameter(line, boundary_of(b));\n    if (hits.any())\n    {\n        auto const t = clamp(hits.first(), ScalarT(0), len);\n        for (auto const& hit : hits)\n        {\n            if (ScalarT(0) <= hit && hit <= len)\n                return true; // cylinder axis intersects aabb\n\n            if (t != clamp(hit, ScalarT(0), len))\n                return true; // intersections before and after the axis can only occur if it lies within aabb\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "cylinder_boundary_no_caps<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // alternative idea that is more efficient:\n    // compute the polygon of the aabb from the projection in cylinder direction and intersect it with a circle\n    //\n    // line = inf_of(c.axis);\n    // len = length(c.axis);\n    // compute planes p1 and p2 spanned by both caps\n    // foreach(vertex in vertices_of(b)) {\n    //      t = coordinates(line, vertex);\n    //      if (0 <= t <= len) add(vertex - t*line.dir);\n    // }\n    // foreach(edge in edges_of(b)) {\n    //      p = intersection(edge, p1);\n    //      if (p.has_value()) add(p.value());\n    //      p = intersection(edge, p2);\n    //      if (p.has_value()) add(p.value() - len*line.dir);\n    // }\n    // compute polygon as convex hull of all added vertices\n    // return intersects(caps_of(c)[0], polygon); // maybe in 2D\n\n    if (!intersects(aabb_of(c), b))\n        return false;\n\n    // check intersections between line through the axis and the aabb\n    auto const line = inf_of(c.axis);\n    auto const len = length(c.axis);\n    auto const intersects_at = [&](ScalarT t) { return intersects(sphere_boundary<2, ScalarT, 3>(line[t], c.radius, line.dir), b); };\n\n    auto const hits = intersection_parameter(line, boundary_of(b));\n    for (auto const& hit : hits)\n        if (ScalarT(0) < hit && hit < len && intersects_at(hit))\n            return true;\n\n    // test disks at both cylinder ends\n    if (intersects(sphere_boundary<2, ScalarT, 3>(c.axis.pos0, c.radius, line.dir), b) || //\n        intersects(sphere_boundary<2, ScalarT, 3>(c.axis.pos1, c.radius, line.dir), b))\n        return true;\n\n    // now only intersections between aabb edges and cylinder mantle remain\n    for (auto const& edge : edges_of(b))\n    {\n        auto [te, tl] = closest_points_parameters(edge, line);\n        if (ScalarT(0) < tl && tl < len && intersects_at(tl))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "inf_cylinder<D, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<D, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (intersects(c.axis, b))\n        return true;\n\n    auto const r2 = c.radius * c.radius;\n    for (auto const& edge : edges_of(b))\n        if (distance_sqr(edge, c.axis) <= r2)\n            return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "BaseT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "pyramid<BaseT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, typename BaseT::scalar_t> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "decltype((void)faces_of(p), true)"
        },
        "body": "    // SAT: box faces\n    if (!intersects(aabb_of(p), b))\n        return false;\n\n    // SAT: pyramid faces\n    using vec_t = vec<3, typename BaseT::scalar_t>;\n    {\n        auto const faces = faces_of(p);\n        constexpr int max_axes_count = 1 + faces.mantle.size();\n\n        auto axes = array<vec_t, max_axes_count>();\n        size_t curr_axis = 0;\n        axes[curr_axis++] = normal_of(faces.base);\n        for (auto const& face : faces.mantle)\n            axes[curr_axis++] = normal_of(face);\n\n        if (!detail::intersects_SAT(p, b, axes))\n            return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "BaseT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "pyramid_boundary_no_caps<BaseT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, typename BaseT::scalar_t> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "decltype((void)faces_of(p), true)"
        },
        "body": "    // SAT: box faces\n    if (!intersects(aabb_of(p), b))\n        return false;\n\n    auto const faces = faces_of(p);\n    return detail::intersects_any_array(b, faces, std::make_index_sequence<faces.size()>{});\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<2, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (!intersects(aabb_of(a), b))\n        return false;\n\n    auto p0 = a.pos0;\n    auto p1 = a.pos1;\n    auto p2 = a.pos2;\n    if (contains(b, p0) || contains(b, p1) || contains(b, p2))\n        return true;\n\n    auto aabb_pts = vertices_of(b);\n\n    auto const is_separate = [&](pos<2, ScalarT> pa, vec<2, ScalarT> n, pos<2, ScalarT> pb)\n    {\n        auto da = dot(n, pa);\n        auto db = dot(n, pb);\n\n        // TODO: faster\n        auto a_min = min(da, db);\n        auto a_max = max(da, db);\n\n        auto b_min = dot(n, aabb_pts[0]);\n        auto b_max = b_min;\n        for (auto i = 1u; i < 4; ++i)\n        {\n            auto d = dot(n, aabb_pts[i]);\n            b_min = min(b_min, d);\n            b_max = max(b_max, d);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "tri_in,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "bb_in",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    using pos_t = pos<3, ScalarT>;\n    using vec_t = vec<3, ScalarT>;\n\n    auto const center = centroid_of(bb_in);\n    auto const amin = pos_t(bb_in.min - center);\n    auto const amax = pos_t(bb_in.max - center);\n    auto const bb = aabb<3, ScalarT>(amin, amax);\n\n    auto const p0 = pos_t(tri_in.pos0 - center);\n    auto const p1 = pos_t(tri_in.pos1 - center);\n    auto const p2 = pos_t(tri_in.pos2 - center);\n\n    // early out: AABB vs tri AABB\n    auto tri_aabb = aabb_of(p0, p1, p2);\n    if (tri_aabb.max.x < amin.x || tri_aabb.max.y < amin.y || tri_aabb.max.z < amin.z || //\n        tri_aabb.min.x > amax.x || tri_aabb.min.y > amax.y || tri_aabb.min.z > amax.z)\n        return false;\n\n    auto const proper_contains = [](aabb<3, ScalarT> const& b, pos_t const& p)\n    {\n        return b.min.x < p.x && p.x < b.max.x && //\n               b.min.y < p.y && p.y < b.max.y && //\n               b.min.z < p.z && p.z < b.max.z;\n    };\n\n    // early in: tri points vs AABB\n    if (proper_contains(bb, p0) || proper_contains(bb, p1) || proper_contains(bb, p2))\n        return true;\n\n    // get adjusted tri base plane\n    auto plane = tg::plane<3, ScalarT>(normal_of(tri_in), p0);\n\n    // fast plane / AABB test\n    {\n        auto pn = plane.normal;\n        auto bn = dot(abs(pn), amax);\n\n        // min dis: d - bn\n        if (bn < -plane.dis)\n            return false;\n\n        // max dis: d + bn\n        if (-plane.dis < -bn)\n            return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "seg,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "disk",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto t = intersection(seg, tg::plane<3, ScalarT>(disk.normal, disk.center));\n    return t.has_value() && distance_sqr(t.value(), disk.center) <= pow2(disk.radius);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "disk,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "seg",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(seg, disk);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<2, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "box<2, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (a.center == b.center)\n        return true;\n\n    auto const ab = b.center - a.center;\n    auto const ba = -ab;\n\n    /// compute the smallest corner of box in direction d\n    auto const min_point = [](tg::dir2 d, box<2, ScalarT> const& box)\n    {\n        auto point = box.center;\n        if (dot(d, box.half_extents[0]) > 0)\n            point -= box.half_extents[0];\n        else\n            point += box.half_extents[0];\n        if (dot(d, box.half_extents[1]) > 0)\n            point -= box.half_extents[1];\n        else\n            point += box.half_extents[1];\n        return point;\n    };\n\n    // the idea here is that we need only check the two planes facing the center of the other bounding box\n    // and only need to check against the smallest corner\n\n    // check planes of a vs smallest point of b\n    if (dot(ab, a.half_extents[0]) > 0)\n    {\n        auto plane = tg::plane2(normalize(a.half_extents[0]), a.center + a.half_extents[0]);\n        auto point_to_check = min_point(plane.normal, b);\n        if (signed_distance(point_to_check, plane) > 0)\n            return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "dont_deduce<ScalarT>",
                    "parameter_name": "eps",
                    "default_value": "ScalarT(0"
                }
            ],
            "return_type": "bool"
        },
        "body": "    // if center is further away than radius, there cannot be any intersection\n\n    auto const d_nx = signed_distance(s.center, f.planes[f.plane_idx_neg_x]);\n    if (d_nx > s.radius + eps)\n        return false;\n\n    auto const d_ny = signed_distance(s.center, f.planes[f.plane_idx_neg_y]);\n    if (d_ny > s.radius + eps)\n        return false;\n\n    auto const d_nz = signed_distance(s.center, f.planes[f.plane_idx_neg_z]);\n    if (d_nz > s.radius + eps)\n        return false;\n\n    auto const d_px = signed_distance(s.center, f.planes[f.plane_idx_pos_x]);\n    if (d_px > s.radius + eps)\n        return false;\n\n    auto const d_py = signed_distance(s.center, f.planes[f.plane_idx_pos_y]);\n    if (d_py > s.radius + eps)\n        return false;\n\n    auto const d_pz = signed_distance(s.center, f.planes[f.plane_idx_pos_z]);\n    if (d_pz > s.radius + eps)\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "bb",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    using halfspace_t = halfspace<3, ScalarT>;\n\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_z]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_z]), bb))\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "bb",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    using halfspace_t = halfspace<3, ScalarT>;\n\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_z]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_z]), bb))\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "inf_frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "dont_deduce<ScalarT>",
                    "parameter_name": "eps",
                    "default_value": "ScalarT(0"
                }
            ],
            "return_type": "bool"
        },
        "body": "    // if center is further away than radius, there cannot be any intersection\n\n    auto const d_nx = signed_distance(s.center, f.planes[f.plane_idx_neg_x]);\n    if (d_nx > s.radius + eps)\n        return false;\n\n    auto const d_ny = signed_distance(s.center, f.planes[f.plane_idx_neg_y]);\n    if (d_ny > s.radius + eps)\n        return false;\n\n    auto const d_px = signed_distance(s.center, f.planes[f.plane_idx_pos_x]);\n    if (d_px > s.radius + eps)\n        return false;\n\n    auto const d_py = signed_distance(s.center, f.planes[f.plane_idx_pos_y]);\n    if (d_py > s.radius + eps)\n        return false;\n\n    auto const d_pz = signed_distance(s.center, f.planes[f.plane_idx_pos_z]);\n    if (d_pz > s.radius + eps)\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "inf_frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "bb",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    using halfspace_t = halfspace<3, ScalarT>;\n\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_z]), bb))\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects_conservative",
            "parameters": [
                {
                    "type_name": "inf_frustum<3, ScalarT> const&",
                    "parameter_name": "f,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "bb",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    using halfspace_t = halfspace<3, ScalarT>;\n\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_neg_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_x]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_y]), bb))\n        return false;\n    if (!intersects(halfspace_t(f.planes[f.plane_idx_pos_z]), bb))\n        return false;\n\n    // conservative approximation!\n    return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_plane3",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    // classify vertices\n    auto sign_v1 = signed_distance(t.pos0, plane) < 0 ? false : true;\n    auto sign_v2 = signed_distance(t.pos1, plane) < 0 ? false : true;\n    auto sign_v3 = signed_distance(t.pos2, plane) < 0 ? false : true;\n\n    // exclude some degenerate cases? e.g. vertices of triangle on same positions, angle constraints..\n\n    if (sign_v1 == sign_v2 && sign_v2 == sign_v3) // no intersection (early out)\n        return {};\n\n    // isolated vertex\n    bool iv = (sign_v1 == sign_v2) ? sign_v3 : (sign_v1 == sign_v3) ? sign_v2 : sign_v1;\n\n    pos<3, ScalarT> i1, i2;\n\n    // intersection exists (exactly 2 vertices on one side of the plane and exactly 1 vertex on the other side)\n    if (iv == sign_v1)\n    {\n        i1 = intersection(segment<3, ScalarT>(t.pos0, t.pos1), plane).value();\n        i2 = intersection(segment<3, ScalarT>(t.pos0, t.pos2), plane).value();\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_triangle3",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return intersection(plane, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    tg::array<pos<3, ScalarT>, 3> triangle_pos = {t.pos0, t.pos1, t.pos2};\n    ScalarT sign = 0;\n\n    for (auto tr : triangle_pos)\n    {\n        if (sign == ScalarT(0))\n        {\n            sign = dot(plane.normal, tr) - plane.dis;\n            if (sign == ScalarT(0))\n                return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(plane, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_triangle3",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t1,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t2",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    // early out: check with plane clamped by triangle t1\n    auto const plane_t1 = plane_of(t1);\n\n    if (!intersects(t2, plane_t1))\n        return {};\n\n    array<pos<3, ScalarT>, 2> insecs;\n    array<segment<3, ScalarT>, 3> segments_t1 = edges_of(t1);\n    array<segment<3, ScalarT>, 3> segments_t2 = edges_of(t2);\n    int insec_count = 0;\n\n    // check intersection of t1 segments with t2\n    for (auto const& s : segments_t1)\n    {\n        auto insec = intersection(s, t2);\n\n        if (insec.has_value())\n        {\n            insecs[insec_count++] = insec.value();\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "seg,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<pos<3,ScalarT>>"
        },
        "body": "    dir<3, ScalarT> normal_t = normalize(cross((t.pos1 - t.pos0), (t.pos2 - t.pos0)));\n\n    plane<3, ScalarT> plane_t = plane<3, ScalarT>(normal_t, t.pos0);\n    // intersection point segment-plane\n    auto insec = intersection(seg, plane_t);\n    // early out\n    if (!insec.has_value())\n        return {};\n\n    // insec in triangle?\n    dir<3, ScalarT> a = normalize(cross(t.pos1 - t.pos0, normal_t));\n    dir<3, ScalarT> b = normalize(cross(t.pos2 - t.pos1, normal_t));\n    dir<3, ScalarT> c = normalize(cross(t.pos0 - t.pos2, normal_t));\n    bool b_a = signed_distance(insec.value(), plane<3, ScalarT>(a, t.pos1)) <= 0 ? false : true;\n    bool b_b = signed_distance(insec.value(), plane<3, ScalarT>(b, t.pos2)) <= 0 ? false : true;\n    bool b_c = signed_distance(insec.value(), plane<3, ScalarT>(c, t.pos0)) <= 0 ? false : true;\n\n    if (b_a == b_b && b_b == b_c)\n        return insec;\n\n    return {};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_triangle3",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "seg",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<pos<3,ScalarT>>"
        },
        "body": "    return intersection(seg, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "bb",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    line<3, ScalarT> segment_line = {s.pos0, normalize(s.pos1 - s.pos0)};\n    auto param_insec = intersection_parameter(segment_line, bb);\n\n    if (!param_insec.has_value())\n        return {};\n\n    // parameters\n    auto a = param_insec.value().start;\n    auto b = param_insec.value().end;\n\n    // intersection may exist\n    if (param_insec.value().start < length(s) && param_insec.value().end < length(s))\n    {\n        return segment<3, ScalarT>{segment_line.pos + segment_line.dir * a, segment_line.pos + segment_line.dir * b};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_aabb3",
            "parameters": [
                {
                    "type_name": "aabb<3, ScalarT> const&",
                    "parameter_name": "bb,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return intersection(s, bb);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "bx",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    // early-out: Both segment points inside of box\n    if (contains(bx, s.pos0) && contains(bx, s.pos1))\n        return s;\n\n    line<3, ScalarT> segment_line = {s.pos0, normalize(s.pos1 - s.pos0)};\n    auto param_insec = intersection_parameter(segment_line, bx);\n\n    if (!param_insec.has_value())\n        return {};\n\n    // parameters\n    auto a = param_insec.value().start;\n    auto b = param_insec.value().end;\n\n    // one point of the segment inside the box\n    if (contains(bx, s.pos0))\n        return segment<3, ScalarT>{s.pos0, segment_line.pos + segment_line.dir * b};\n\n    if (contains(bx, s.pos1))\n        return segment<3, ScalarT>{segment_line.pos + segment_line.dir * a, s.pos1};\n\n    // intersection may exist\n    if (a < length(s) && b < length(s) && a >= 0 && b > 0)\n    {\n        return segment<3, ScalarT>{segment_line.pos + segment_line.dir * a, segment_line.pos + segment_line.dir * b};\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "capsule<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_capsule3",
            "parameters": [
                {
                    "type_name": "capsule<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "cylinder<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_cylinder3",
            "parameters": [
                {
                    "type_name": "cylinder<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "ellipse<3, ScalarT> const&",
                    "parameter_name": "e",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, e);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_ellipse3",
            "parameters": [
                {
                    "type_name": "ellipse<3, ScalarT> const&",
                    "parameter_name": "e,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, e);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "e",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, e);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_sphere3",
            "parameters": [
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "e,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, e);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "tube<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_tube3",
            "parameters": [
                {
                    "type_name": "tube<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_cone3",
            "parameters": [
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "cc::optional<segment<3,ScalarT>>"
        },
        "body": "    return detail::intersection_segment_object_impl(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_segment3",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "cylinder_boundary<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,tg::pos<3,ScalarT>>"
        },
        "body": "    // TODO: This is a standard solution that can be applied to any boundary case\n    auto const line = line3::from_points(s.pos0, s.pos1);\n    auto const params = intersection_parameter(line, c);\n\n    if (!params.any())\n        return {};\n\n    auto const dist = distance(s.pos0, s.pos1);\n    auto n_hits = 0;\n    tg::pos<3, ScalarT> ps[2];\n    for (auto i = 0; i < params.size(); ++i)\n    {\n        auto const t = params[i];\n        if (ScalarT(0) <= t && t <= dist)\n        {\n            ps[n_hits++] = line[t];\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersection_cylinder_boundary3",
            "parameters": [
                {
                    "type_name": "cylinder_boundary<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "hits<2,tg::pos<3,ScalarT>>"
        },
        "body": "    return intersection(s, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (a.center == b.center)\n        return true;\n\n    // Separating Axes Theorem\n    auto const axis_check = [](tg::dir<3, ScalarT> d, box<3, ScalarT> const& box_a, box<3, ScalarT> const& box_b) -> bool\n    {\n        ScalarT minProja = tg::max<ScalarT>();\n        ScalarT maxProja = tg::min<ScalarT>();\n        ScalarT minProjb = tg::max<ScalarT>();\n        ScalarT maxProjb = tg::min<ScalarT>();\n\n        for (auto x : {-1, 1})\n            for (auto y : {-1, 1})\n                for (auto z : {-1, 1})\n                {\n                    vec3 v = {float(x), float(y), float(z)};\n\n                    auto proja = dot(d, box_a.half_extents * v);\n                    if (proja < minProja)\n                        minProja = proja;\n                    if (proja > maxProja)\n                        maxProja = proja;\n\n                    auto projb = dot(d, box_b.half_extents * v);\n                    if (projb < minProjb)\n                        minProjb = projb;\n                    if (projb > maxProjb)\n                        maxProjb = projb;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return distance(a.center, b.center) <= (a.radius + b.radius);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "b,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // early-out: sphere-center inside box\n    if (contains(b, s.center))\n        return true;\n\n    array<pos<3, ScalarT>, 8> box_vertices = vertices_of(b);\n    // box vertex inside the sphere\n    for (auto const& v : box_vertices)\n    {\n        if (length_sqr(v - s.center) < pow2(s.radius))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(b, s);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (distance(a, b.center) <= b.radius)\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "a,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "b",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(b, a);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    float sign = 0;\n\n    // iterate over box-vertices\n    for (auto x : {-1, 1})\n        for (auto y : {-1, 1})\n            for (auto z : {-1, 1})\n            {\n                pos<3, ScalarT> box_vertex = box.center + x * box.half_extents[0] + y * box.half_extents[1] + z * box.half_extents[2];\n                if (sign == 0)\n                {\n                    sign = dot(plane.normal, box_vertex) - plane.dis;\n\n                    if (sign == 0)\n                        return true;\n\n                    continue;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "plane,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(box, plane);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "triangle",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // early out\n    if (contains(box, triangle))\n        return true;\n\n    // intersection of box with triangle-plane\n    tg::plane<3, ScalarT> plane_of_triangle = tg::plane_of(triangle);\n    if (!intersects(plane_of_triangle, box))\n        return false;\n\n    array<segment<3, ScalarT>, 3> edges_triangle = edges_of(triangle);\n    array<segment<3, ScalarT>, 12> edges_box = edges_of(box);\n\n    // intersection of triangle edges with box\n    for (auto& e : edges_triangle)\n    {\n        if (intersects(e, box))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "triangle,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(box, triangle);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<2, ScalarT> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT> const&",
                    "parameter_name": "sphere",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    array<pos<2, ScalarT>, 4> vertices_box = vertices_of(box);\n    array<segment<2, ScalarT>, 4> edges_box = edges_of(box);\n\n    if (contains(box, sphere.center))\n        return true;\n\n    for (auto const& e : edges_box)\n    {\n        if (intersects(e, sphere))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT> const&",
                    "parameter_name": "sphere,",
                    "default_value": ""
                },
                {
                    "type_name": "box<2, ScalarT> const&",
                    "parameter_name": "box",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(box, sphere);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "int",
                "variable_name": "D",
                "default_value": ""
            },
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<D, ScalarT> const&",
                    "parameter_name": "sphere,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<D, ScalarT> const&",
                    "parameter_name": "hs",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if (dot(hs.normal, sphere.center) - hs.dis <= sphere.radius)\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<3, ScalarT> const&",
                    "parameter_name": "hs,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "sphere",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(sphere, hs);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<3, ScalarT> const&",
                    "parameter_name": "hs",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    array<pos<3, ScalarT>, 8> vertices_box = vertices_of(box);\n    for (auto const& v : vertices_box)\n    {\n        if (dot(hs.normal, v) - hs.dis <= 0)\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<3, ScalarT> const&",
                    "parameter_name": "hs,",
                    "default_value": ""
                },
                {
                    "type_name": "box<3, ScalarT> const&",
                    "parameter_name": "box",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(box, hs);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<3, ScalarT> const&",
                    "parameter_name": "hs",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if ((dot(hs.normal, s.pos0) - hs.dis) <= 0 || (dot(hs.normal, s.pos1) - hs.dis) <= 0)\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<3, ScalarT> const&",
                    "parameter_name": "hs,",
                    "default_value": ""
                },
                {
                    "type_name": "segment<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(s, hs);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // triangle vertex inside sphere\n    if (contains(s, t.pos0) || contains(s, t.pos1) || contains(s, t.pos2))\n        return true;\n\n    plane<3, ScalarT> plane_t = plane_of(t);\n\n    // check if the closest point on triangle to sphere center is inside the sphere\n    auto cp = closest_points(s.center, t);\n\n    if (contains(s, cp.first) && contains(s, cp.second))\n        return true;\n\n    // triangle edge intersects sphere\n    for (auto const& e : edges_of(t))\n    {\n        if (intersects(e, s))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<3, ScalarT> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(t, s);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "p",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto plane_s = tg::plane<3, ScalarT>(s.normal, s.center);\n\n    // sphere center on plane\n    if (contains(p, s.center))\n        return true;\n\n    // no intersection if planes are parallel\n    if ((plane_s.normal == p.normal || plane_s.normal == -p.normal) && !contains(p, s.center))\n        return false;\n\n    // line intersection of two planes\n    auto insec = intersection(plane_s, p);\n\n    // if distance of plane intersection is inside the sphere, intersection exists\n    if (distance_sqr(insec, s.center) <= pow2(s.radius))\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(s, p);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "p,",
                    "default_value": ""
                },
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // cone base intersects the plane\n    if (intersects(c.base, p))\n        return true;\n\n    auto d_cone_tip = (dot(p.normal, apex_of(c)) - p.dis) >= 0;\n    auto d_cone_base = (dot(p.normal, c.base.center) - p.dis) >= 0;\n\n    // base and tip of the cone are on different sides of the plane\n    if (d_cone_tip != d_cone_base)\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "plane<3, ScalarT> const&",
                    "parameter_name": "p",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(p, c);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "halfspace<3, ScalarT> const",
                    "parameter_name": "hs",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    if ((dot(hs.normal, t.pos0) - hs.dis <= 0) || (dot(hs.normal, t.pos1) - hs.dis <= 0) || (dot(hs.normal, t.pos2) - hs.dis <= 0))\n        return true;\n\n    return false;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "halfspace<3, ScalarT> const",
                    "parameter_name": "hs,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(t, hs);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "s,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    // circle inside triangle or triangle vertex inside the circle\n    if (contains(s, centroid_of(t)) || contains(s, t.pos0) || contains(s, t.pos1) || contains(s, t.pos2))\n        return true;\n\n    // area of triangle intersects with circle\n    auto cp = closest_points(s.center, t);\n\n    if (contains(s, cp.first) && contains(s, cp.second))\n        return true;\n\n    // triangle edge intersects with circle\n    for (auto const& e : edges_of(t))\n    {\n        if (intersects(e, s))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "sphere<2, ScalarT, 3> const&",
                    "parameter_name": "s",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(s, t);\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c,",
                    "default_value": ""
                },
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    auto mid_axis = tg::segment<3, ScalarT>(c.base.center, apex_of(c));\n\n    // area of the triangle intersects with cone\n    if (intersects(mid_axis, t))\n        return true;\n\n    // triangle intersects with the cone base\n    if (intersects(c.base, t))\n        return true;\n\n    // at least one segment of triangle intersects with cone\n    for (auto const& e : edges_of(t))\n    {\n        if (intersects(e, c))\n            return true;\n"
    },
    {
        "template-parameters": [
            {
                "typename": "class",
                "variable_name": "ScalarT",
                "default_value": ""
            }
        ],
        "function_declaration": {
            "modyfiers": [
                "[[nodiscard]]",
                "constexpr"
            ],
            "name": "intersects",
            "parameters": [
                {
                    "type_name": "triangle<3, ScalarT> const&",
                    "parameter_name": "t,",
                    "default_value": ""
                },
                {
                    "type_name": "cone<3, ScalarT> const&",
                    "parameter_name": "c",
                    "default_value": ""
                }
            ],
            "return_type": "bool"
        },
        "body": "    return intersects(c, t);\n"
    }
]